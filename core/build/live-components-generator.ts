// ðŸš€ FluxStack Live Components - Auto Registration Generator
// Automatically generates component registration during build time

import { existsSync, readdirSync, writeFileSync, unlinkSync, readFileSync } from 'fs'
import { join, extname, basename } from 'path'
import { buildLogger } from '../utils/build-logger'

export interface ComponentInfo {
  fileName: string
  className: string
  componentName: string
  filePath: string
}

export class LiveComponentsGenerator {
  private componentsPath: string
  private registrationFilePath: string
  private backupFilePath: string

  constructor() {
    this.componentsPath = join(process.cwd(), 'app', 'server', 'live')
    this.registrationFilePath = join(process.cwd(), 'app', 'server', 'live', 'register-components.ts')
    this.backupFilePath = join(process.cwd(), 'app', 'server', 'live', 'register-components.backup.ts')
  }

  /**
   * Scan the live components directory and discover all components
   */
  discoverComponents(): ComponentInfo[] {
    if (!existsSync(this.componentsPath)) {
      return []
    }

    const components: ComponentInfo[] = []
    const files = readdirSync(this.componentsPath)

    for (const file of files) {
      // Skip non-TypeScript files, backup files, and the registration file itself
      if (!file.endsWith('.ts') || 
          file === 'register-components.ts' || 
          file.includes('.backup.') ||
          file.includes('.bak')) {
        continue
      }

      const filePath = join(this.componentsPath, file)
      const fileName = basename(file, extname(file))
      
      try {
        // Read file content to extract class name
        const content = readFileSync(filePath, 'utf-8')
        
        // Look for class exports that extend LiveComponent
        const classMatches = content.match(/export\s+class\s+(\w+)\s+extends\s+LiveComponent/g)
        
        if (classMatches && classMatches.length > 0) {
          for (const match of classMatches) {
            const classNameMatch = match.match(/class\s+(\w+)/)
            if (classNameMatch) {
              const className = classNameMatch[1]
              const componentName = className.replace(/Component$/, '')
              
              components.push({
                fileName,
                className,
                componentName,
                filePath: `./${fileName}`
              })

              buildLogger.step(`Discovered component: ${className} â†’ ${componentName}`)
            }
          }
        }
      } catch (error) {
        // Silently skip files that can't be analyzed
      }
    }

    return components
  }

  /**
   * Generate the registration file with all discovered components
   */
  generateRegistrationFile(components: ComponentInfo[]): void {
    // Backup existing file if it exists
    if (existsSync(this.registrationFilePath)) {
      const existingContent = readFileSync(this.registrationFilePath, 'utf-8')
      writeFileSync(this.backupFilePath, existingContent)
    }

    // Generate imports
    const imports = components
      .map(comp => `import { ${comp.className} } from "${comp.filePath}"`)
      .join('\n')

    // Generate registrations
    const registrations = components
      .map(comp => `    componentRegistry.registerComponentClass('${comp.componentName}', ${comp.className})`)
      .join('\n')

    // Generate file content
    const fileContent = `// ðŸ”¥ Auto-generated Live Components Registration
// This file is automatically generated during build time - DO NOT EDIT MANUALLY
// Generated at: ${new Date().toISOString()}

${imports}
import { componentRegistry } from "@/core/server/live/ComponentRegistry"

// Register all components statically for production bundle
function registerAllComponents() {
  try {
    // Auto-generated component registrations
${registrations}
    
    console.log('ðŸ“ Live components registered successfully! (${components.length} components)')
  } catch (error) {
    console.warn('âš ï¸ Error registering components:', error)
  }
}

// Auto-register components
registerAllComponents()

// Export all components to ensure they're included in the bundle
export { 
${components.map(comp => `  ${comp.className}`).join(',\n')}
}
`

    writeFileSync(this.registrationFilePath, fileContent)
    buildLogger.success(`Generated registration for ${components.length} components`)
  }

  /**
   * Restore the original registration file from backup
   */
  restoreOriginalFile(): void {
    if (existsSync(this.backupFilePath)) {
      const backupContent = readFileSync(this.backupFilePath, 'utf-8')
      writeFileSync(this.registrationFilePath, backupContent)
      unlinkSync(this.backupFilePath)
    }
  }

  /**
   * Check if the current registration file is auto-generated
   */
  isAutoGenerated(): boolean {
    if (!existsSync(this.registrationFilePath)) {
      return false
    }

    const content = readFileSync(this.registrationFilePath, 'utf-8')
    return content.includes('// ðŸ”¥ Auto-generated Live Components Registration')
  }

  /**
   * Pre-build hook: Generate registration file
   */
  async preBuild(): Promise<ComponentInfo[]> {
    buildLogger.section('Live Components Discovery', 'ðŸš€')

    const components = this.discoverComponents()

    if (components.length === 0) {
      buildLogger.warn('No Live Components found')
      return []
    }

    // Create table of discovered components
    const componentData = components.map(c => ({
      component: c.componentName,
      className: c.className,
      file: c.fileName + '.ts'
    }))

    buildLogger.table(
      [
        { header: 'Component', key: 'component', width: 20, align: 'left', color: 'cyan' },
        { header: 'Class Name', key: 'className', width: 25, align: 'left' },
        { header: 'File', key: 'file', width: 20, align: 'left', color: 'gray' }
      ],
      componentData
    )

    this.generateRegistrationFile(components)

    return components
  }

  /**
   * Post-build hook: Clean up generated file (optional)
   */
  async postBuild(keepGenerated: boolean = false): Promise<void> {
    buildLogger.step('Cleaning up Live Components registration...')

    if (keepGenerated) {
      // Remove backup since we're keeping the generated version
      if (existsSync(this.backupFilePath)) {
        unlinkSync(this.backupFilePath)
      }
    } else {
      this.restoreOriginalFile()
    }
  }

  /**
   * Development mode: Check if registration needs update
   */
  needsUpdate(): boolean {
    if (!this.isAutoGenerated()) {
      return false // Manual file, don't touch
    }

    const components = this.discoverComponents()
    const currentContent = readFileSync(this.registrationFilePath, 'utf-8')
    
    // Check if all discovered components are in the current file
    for (const comp of components) {
      if (!currentContent.includes(`'${comp.componentName}', ${comp.className}`)) {
        return true
      }
    }

    return false
  }

  /**
   * Development mode: Update registration if needed
   */
  updateIfNeeded(): void {
    if (this.needsUpdate()) {
      buildLogger.info('Live Components changed, updating registration...')
      const components = this.discoverComponents()
      this.generateRegistrationFile(components)
    }
  }
}

// Export singleton instance
export const liveComponentsGenerator = new LiveComponentsGenerator()